---
- include: do_we_have_a_dump.yml

# We have to be root for this, that's why we clean before the following block.
- name: Make sure that we have a clean space to work in
  file:
    path: "/tmp/{{ item }}"
    state: absent
  with_items:
    - to_dump.tar
    - to_dump.tar.gz

- block:
  - name: Copy over initial dump
    copy:
      src: "{{ zbackup_initial_dump_file }}"
      dest: /tmp/to_dump.tar.gz
  - name: Ensure that we don't have a gzipped tar
    shell: "gzip -d /tmp/to_dump.tar.gz || mv /tmp/to_dump.tar.gz /tmp/to_dump.tar"
  - name: Send that initial dump into the backup
    shell: "{{ zbackup_storage_path }}/dump < /tmp/to_dump.tar" 
  - name: Clean up after ourselves
    file:
      path: "/tmp/{{ item }}"
      state: absent
    with_items:
      - to_dump.tar
      - to_dump.tar.gz
  - include: do_we_have_a_dump.yml
  become: yes
  become_user: "{{ zbackup_owner }}"
  when: not latest_timestamp.stat.exists and zbackup_initial_dump_file != ''

- block:
  - name: Run initial dump fetch command
    shell: "{{ zbackup_initial_dump_fetch_command }} | {{ zbackup_storage_path }}/dump"
  - include: do_we_have_a_dump.yml
  become: yes
  become_user: "{{ zbackup_owner }}"
  when: not latest_timestamp.stat.exists and zbackup_initial_dump_fetch_command != ''

- fail:
    msg: We couldn't manage to import an initial dump!
  when: not latest_timestamp.stat.exists
